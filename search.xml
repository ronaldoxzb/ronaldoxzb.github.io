<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>世界的阴暗面，和我们假装美好的教育</title>
      <link href="/2021/08/31/book-record/"/>
      <url>/2021/08/31/book-record/</url>
      
        <content type="html"><![CDATA[<h1 id="世界的阴暗面，和我们假装美好的教育"><a href="#世界的阴暗面，和我们假装美好的教育" class="headerlink" title="世界的阴暗面，和我们假装美好的教育"></a>世界的阴暗面，和我们假装美好的教育</h1><p>—-读《房思琪的初恋乐园》有感</p><p>作者：柒祭·落</p><p><code>读完整本小说，整个人都沉浸在那种悲伤中，想到之前看过的《素媛》和《熔炉》，小说中最让我心痛的一个词叫“世界的背面”。如果思琪活在世界的正面，健康快乐的长大，像大多数同龄孩子一样，为考试成绩而忧愁，为同桌的男孩而害羞，就是我们大多数人的人生。可我们都忘了，这个世界还有背面，那些我们无法言说无法体会的痛楚和丑陋，依然在如今这个看似美好的世界，活生生的存在着。</code></p><p>读了小说，看了林奕含的采访视频，发现那个看着温柔美好的女孩子，对文学有着很深的爱，读过的书，书里的人，写书的人，都成为了她的信仰，成为了她深深的爱，而这也成了她对老师又爱又恨的原因。她爱老师和她信仰相同，在她对文学有懵懵懂懂的理解时，老师是那个让她无比崇拜的人，可是在她还没有真正理解文学里的爱时，她崇拜的人却深深的伤害了她。也许最后，林奕含的自杀，不是因为那段痛苦的回忆，而是她无法接受她爱的信仰也有可能只是一种假象。</p><p>那些书写了美好世界，完美爱情的人，在现实世界，却可能是个虐打妻子的暴力男。林奕含无法接受这样的虚假。</p><blockquote><p>最后，让我深思而心痛的是，我们缺失的性教育。</p></blockquote><p>在思琪问妈妈，我们家什么都有，就是没有性教育的时候，妈妈的回答是只有需要性的人才需要性教育，所谓教育不就是这样吗？</p><p>所谓教育不就是这样吗？</p><p>我们需要什么，或者说我们认为孩子需要什么，我们就教给他们什么。可是孩子会在生活中遇到我们以为不会发生的事，而这种时候，孩子会很迷茫，TA不知道什么是对什么是错，也不知道该如何面对。而试探性的问问父母，父母的反应也依旧停留于已有的认知，而没有思考孩子为什么会这么问。思琪的父母如此，怡婷的父母同样，所以怡婷才会在思琪痛苦的时候，没有帮助和陪伴她，反而给了她更多的伤害。因为怡婷也不知道思琪是受到了伤害，她认为这件事超出了教育认知里的常规，所以就是错的。</p><p>纵然有人想努力用各种方式，将这个世界的阴暗面撕开，纵然有很多人在看过后愤怒，心痛，可我们却不得不承认，在愤怒和心痛过之后，我们依然无法阻止这样的事继续发生。我们读书，在书里看到美好的世界，也看到阴暗的世界。这一切，都是真实的，真实的美好，也真实的阴暗，并且，我们无力改变。</p><h3 id="这就是让人最心痛的。"><a href="#这就是让人最心痛的。" class="headerlink" title="这就是让人最心痛的。"></a>这就是让人最心痛的。</h3><p>1991年出生，2017年离世，心痛那个美好姑娘的美好年华，就这样结束。被这个世界的阴暗面，和我们假装美好的教育，合伙谋杀。也许原本，她不用这样过一生。</p>]]></content>
      
      
      <categories>
          
          <category> Reading-Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>egg  + sequelize + mysql + jwt + vue 全栈项目部署</title>
      <link href="/2021/08/31/compose-deploy/"/>
      <url>/2021/08/31/compose-deploy/</url>
      
        <content type="html"><![CDATA[<h3 id="Egg-spider"><a href="#Egg-spider" class="headerlink" title="Egg-spider"></a>Egg-spider</h3><h4 id="后端-egg-js-jwt-mysql-sequelize-redis-docker-docker-compose-nginx-vue-element-ui-全栈获取省市区数据（统计局数据）【工具】项目，实现在docker环境中一键部署"><a href="#后端-egg-js-jwt-mysql-sequelize-redis-docker-docker-compose-nginx-vue-element-ui-全栈获取省市区数据（统计局数据）【工具】项目，实现在docker环境中一键部署" class="headerlink" title="[后端]egg.js(jwt) + mysql(sequelize) + redis + docker + docker-compose + nginx + vue + element-ui 全栈获取省市区数据（统计局数据）【工具】项目，实现在docker环境中一键部署"></a>[后端]egg.js(jwt) + mysql(sequelize) + redis + docker + docker-compose + nginx + vue + element-ui 全栈获取省市区数据（统计局数据）【工具】项目，实现在docker环境中一键部署</h4><h5 id="1-实现用户注册登录"><a href="#1-实现用户注册登录" class="headerlink" title="1 实现用户注册登录"></a>1 实现用户注册登录</h5><h5 id="2-实现统计局省市区数据的爬取"><a href="#2-实现统计局省市区数据的爬取" class="headerlink" title="2 实现统计局省市区数据的爬取"></a>2 实现统计局省市区数据的爬取</h5><h5 id="3-实现大批量excel测试数据"><a href="#3-实现大批量excel测试数据" class="headerlink" title="3 实现大批量excel测试数据"></a>3 实现大批量excel测试数据</h5><h5 id="4-实现资源的监控"><a href="#4-实现资源的监控" class="headerlink" title="4 实现资源的监控"></a>4 实现资源的监控</h5><h5 id="5-实现羽雀API的调用"><a href="#5-实现羽雀API的调用" class="headerlink" title="5 实现羽雀API的调用"></a>5 实现羽雀API的调用</h5><h5 id="6-实现邮件的发送（基于smtp-qq-com"><a href="#6-实现邮件的发送（基于smtp-qq-com" class="headerlink" title="6 实现邮件的发送（基于smtp.qq.com)"></a>6 实现邮件的发送（基于smtp.qq.com)</h5><h4 id="前端-element-ui-https-github-com-PanJiaChen-vue-admin-template-🙏"><a href="#前端-element-ui-https-github-com-PanJiaChen-vue-admin-template-🙏" class="headerlink" title="[前端] element-ui (https://github.com/PanJiaChen/vue-admin-template) 🙏"></a>[前端] element-ui (<a href="https://github.com/PanJiaChen/vue-admin-template">https://github.com/PanJiaChen/vue-admin-template</a>) 🙏</h4><h5 id="PanJiaChen-大佬最精简的一副vue模版（拿来熟悉docker-compose的发布流程）"><a href="#PanJiaChen-大佬最精简的一副vue模版（拿来熟悉docker-compose的发布流程）" class="headerlink" title="PanJiaChen 大佬最精简的一副vue模版（拿来熟悉docker-compose的发布流程）"></a>PanJiaChen 大佬最精简的一副vue模版（拿来熟悉docker-compose的发布流程）</h5><h3 id="Project-back-end-structure-description"><a href="#Project-back-end-structure-description" class="headerlink" title="Project back end structure description"></a>Project back end structure description</h3><h4 id="app"><a href="#app" class="headerlink" title="app"></a>app</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">├── contract</span><br><span class="line">│   └── type.js     swaggerdoc配置文件</span><br><span class="line">├── controller</span><br><span class="line">│   ├── api</span><br><span class="line">│   │   ├── area.js     省市区乡镇村数据获取</span><br><span class="line">│   │   ├── mock.js     生成mock数据生成Excel文件</span><br><span class="line">│   │   ├── system.js       获取系统资源使用情况</span><br><span class="line">│   │   ├── tool</span><br><span class="line">│   │   │   └── email.js        发送邮件</span><br><span class="line">│   │   ├── user.js</span><br><span class="line">│   │   └── yuque.js        羽雀API调用</span><br><span class="line">│   └── view</span><br><span class="line">│       └── page.js     模版引擎渲染index</span><br><span class="line">├── database</span><br><span class="line">│   └── db.js       model层公用</span><br><span class="line">├── extend</span><br><span class="line">│   ├── application.js      app扩展函数</span><br><span class="line">│   └── helper.js       公用函数封装</span><br><span class="line">├── middleware</span><br><span class="line">│   ├── error_handler.js    成功/出错处理等</span><br><span class="line">│   ├── notfound_handler.js     404处理等</span><br><span class="line">│   └── pagination.js       分页器封装</span><br><span class="line">├── model</span><br><span class="line">│   ├── cities.js       市表</span><br><span class="line">│   ├── districts.js        街道表</span><br><span class="line">│   ├── provinces.js        省表</span><br><span class="line">│   ├── towns.js        乡镇表</span><br><span class="line">│   ├── user.js     用户表</span><br><span class="line">│   └── villages.js     村表</span><br><span class="line">├── public      静态资源文件</span><br><span class="line">├── router      路由表（不赘述）</span><br><span class="line">│   ├── api</span><br><span class="line">│   │   ├── area.js     </span><br><span class="line">│   │   ├── mock.js</span><br><span class="line">│   │   ├── system.js</span><br><span class="line">│   │   ├── tool</span><br><span class="line">│   │   │   └── email.js</span><br><span class="line">│   │   ├── user.js</span><br><span class="line">│   │   └── yuque.js</span><br><span class="line">│   └── view</span><br><span class="line">│       └── page.js</span><br><span class="line">├── service     逻辑处理层</span><br><span class="line">│   ├── area.js     </span><br><span class="line">│   ├── cache.js</span><br><span class="line">│   ├── common.js</span><br><span class="line">│   └── user.js</span><br><span class="line">├── utils       暂无</span><br><span class="line">└── view        未做前后端分离前的模版引擎渲染的页面</span><br><span class="line">    ├── index.html</span><br><span class="line">    └── tool.html</span><br></pre></td></tr></table></figure><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── config.default.js   默认配置文件</span><br><span class="line">├── config.local.js     本地开发配置文件</span><br><span class="line">├── config.prod.js      生产配置文件</span><br><span class="line">└── plugin.js       插件配置文件</span><br></pre></td></tr></table></figure><h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── mysql</span><br><span class="line">│   ├── Dockerfile      mysql镜像文件</span><br><span class="line">│   ├── init</span><br><span class="line">│   │   └── init.sql        初始建库执行的sql   </span><br><span class="line">│   └── mysqld.cnf      mysql配置文件</span><br><span class="line">├── redis</span><br><span class="line">│   ├── Dockerfile      redis镜像文件</span><br><span class="line">│   └── redis.conf      redis配置文件</span><br><span class="line">├── server</span><br><span class="line">│   └── Dockerfile      server镜像文件启动</span><br><span class="line">└── web</span><br><span class="line">    ├── Dockerfile      web build 及 nginx镜像文件</span><br><span class="line">    └── nginx.conf      nginx配置文件</span><br></pre></td></tr></table></figure><h3 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h3><h4 id="server-自行安装docker-amp-docker-compose-amp-amp-node"><a href="#server-自行安装docker-amp-docker-compose-amp-amp-node" class="headerlink" title="server(自行安装docker&amp;docker-compose&amp;&amp;node)"></a><code>server(自行安装docker&amp;docker-compose&amp;&amp;node)</code></h4><h5 id="start-mysql-amp-redis"><a href="#start-mysql-amp-redis" class="headerlink" title="start mysql &amp; redis"></a>start mysql &amp; redis</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f docker-compose-dev.yml up     </span><br></pre></td></tr></table></figure><h5 id="start-server"><a href="#start-server" class="headerlink" title="start server"></a>start server</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm i</span><br><span class="line">$ npm run dev</span><br><span class="line">$ open http://localhost:7001/</span><br></pre></td></tr></table></figure><h4 id="web-自行安装node环境"><a href="#web-自行安装node环境" class="headerlink" title="web(自行安装node环境)"></a><code>web(自行安装node环境)</code></h4><h5 id="start-web"><a href="#start-web" class="headerlink" title="start web"></a>start web</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm i</span><br><span class="line">$ npm run dev</span><br><span class="line">$ open http://localhost:9028/</span><br></pre></td></tr></table></figure><h3 id="Deploy-宿主机安装docker-amp-amp-docker-compose"><a href="#Deploy-宿主机安装docker-amp-amp-docker-compose" class="headerlink" title="Deploy(宿主机安装docker&amp;&amp;docker-compose)"></a>Deploy(宿主机安装docker&amp;&amp;docker-compose)</h3><!-- start stop --><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br><span class="line">$ docker-compose stop</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Deploy-Tec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
            <tag> vue </tag>
            
            <tag> nginx </tag>
            
            <tag> docker </tag>
            
            <tag> docker-compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker相关</title>
      <link href="/2021/08/31/docker/"/>
      <url>/2021/08/31/docker/</url>
      
        <content type="html"><![CDATA[<p><img width="300" align="center" src="/images/dockerlogo.png" alt="ronaldoxzb" /></p></p><h3 id="一、集装箱？"><a href="#一、集装箱？" class="headerlink" title="一、集装箱？"></a>一、集装箱？</h3><p>来自于知乎的通俗解释：<br>Docker 的思想来自于 集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。</p><h3 id="docker-核心概念"><a href="#docker-核心概念" class="headerlink" title="docker 核心概念"></a>docker 核心概念</h3><h4 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像(image)"></a>镜像(image)</h4><p><code>类似于虚拟机中的镜像（image），是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。镜像可以用来创建 Docker 容器</code></p><h4 id="仓库-repository-node-js-镜像仓库"><a href="#仓库-repository-node-js-镜像仓库" class="headerlink" title="仓库(repository) node.js 镜像仓库"></a>仓库(repository) <a href="https://hub.docker.com/_/node">node.js 镜像仓库</a></h4><p><code>仓库（Repository）是集中存放镜像文件的场所。类似于代码仓库，这里是镜像仓库。</code></p><h4 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h4><p><code>Docker 利用容器（Container）来运行应用。容器是从镜像创建的运行实例。可以看作一个简易版的 Linux 环境</code></p><h4 id="对比记忆"><a href="#对比记忆" class="headerlink" title="对比记忆"></a>对比记忆</h4><blockquote><p>Java 号称“一次编译，到处运行”，因为 java 虚拟机解决平台的兼容性问题，所以有 java 虚拟机的地方就能跑 java 代码；</p></blockquote><blockquote><p>Docker 是：“一次封装，到处运行”，因为 docker 解决了应用环境的问题，安装了 docker 的平台就能跑“docker 包”，这样就决绝了“开发环境能跑，一上线就崩”的尴尬。</p></blockquote><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">images      List images</span><br><span class="line">ps          List containers</span><br><span class="line">pull        Pull an image or a repository from a registry</span><br><span class="line">push        Push an image or a repository to a registry</span><br><span class="line">rename      Rename a container</span><br><span class="line">restart     Restart one or more containers</span><br><span class="line">rm          Remove one or more containers</span><br><span class="line">rmi         Remove one or more images</span><br><span class="line">run         Run a <span class="built_in">command</span> <span class="keyword">in</span> a new container</span><br></pre></td></tr></table></figure><h4 id="快速启动常用软件-有道云笔记"><a href="#快速启动常用软件-有道云笔记" class="headerlink" title="快速启动常用软件 有道云笔记"></a>快速启动常用软件 <a href="http://note.youdao.com/s/XQGk25P1">有道云笔记</a></h4><h3 id="二、Dockerfile"><a href="#二、Dockerfile" class="headerlink" title="二、Dockerfile"></a>二、Dockerfile</h3><h4 id="什么是-dockerfile"><a href="#什么是-dockerfile" class="headerlink" title="什么是 dockerfile?"></a>什么是 dockerfile?</h4><p><code>Dockerfile 是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker 通过读取Dockerfile中的指令自动生成映像。</code></p><p><code>docker build命令用于从 Dockerfile 构建映像。可以在docker build命令中使用-f标志指向文件系统中任何位置的 Dockerfile。</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /path/to/a/Dockerfile</span><br></pre></td></tr></table></figure><h4 id="Dockerfile-文件说明"><a href="#Dockerfile-文件说明" class="headerlink" title="Dockerfile 文件说明"></a>Dockerfile 文件说明</h4><p><code>Docker 以从上到下的顺序运行 Dockerfile 的指令。为了指定基本映像，第一条指令必须是 FROM。一个声明以＃字符开头则被视为注释。可以在 Docker 文件中使用RUN，CMD，FROM，EXPOSE，ENV等指令。</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># node镜像</span></span><br><span class="line">FROM node:12-alpine as build-stage</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;-------------------- web环境配置 --------------------&quot;</span></span><br><span class="line"><span class="comment"># 指定接下来的工作路径为/app  - 类似于cd命令</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"><span class="comment"># 拷贝前端项目到app目录下</span></span><br><span class="line">COPY ./web/package*.json ./</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">RUN npm i --registry=https://registry.npm.taobao.org</span><br><span class="line">COPY ./web ./</span><br><span class="line"><span class="comment"># 打包 - 目的：丢到nginx下跑</span></span><br><span class="line">RUN npm run build:prod</span><br></pre></td></tr></table></figure><h3 id="三、Docker-Compose"><a href="#三、Docker-Compose" class="headerlink" title="三、Docker Compose"></a>三、Docker Compose</h3><h4 id="什么是-docker-compose"><a href="#什么是-docker-compose" class="headerlink" title="什么是 docker-compose?"></a>什么是 docker-compose?</h4><p><code>Docker-compose 是 docker 的服务编排工具，主要是用来构建多个服务，一般是构建构建多个有关联的服务。</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;2&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  mysql5.7:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    container_name: mysql</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;./mysql5.7/data:/var/lib/mysql&quot;</span></span><br><span class="line">      - <span class="string">&quot;./mysql5.7/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      - ./docker/mysql/init:/docker-entrypoint-initdb.d/ <span class="comment">#执行默认脚本</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    user: root:root</span><br><span class="line">    tty: <span class="literal">true</span></span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      - PROCESS_NUM=1</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=xier0571</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line">      - TIME_STYLE=<span class="string">&quot;+%F %T&quot;</span></span><br><span class="line">      - LANG=en_US.UTF-8</span><br><span class="line">  redis4:</span><br><span class="line">    image: redis:4</span><br><span class="line">    container_name: redis</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;./redis4/conf:/usr/local/etc/redis&quot;</span></span><br><span class="line">      - <span class="string">&quot;./redis4/data:/data&quot;</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    tty: <span class="literal">true</span></span><br><span class="line">    restart: always</span><br><span class="line">    <span class="built_in">command</span>: redis-server --requirepass xier0571</span><br></pre></td></tr></table></figure><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">up                 Create and start containers</span><br><span class="line">down               Stop and remove resources</span><br><span class="line">images             List images</span><br><span class="line">ps                 List containers</span><br><span class="line">top                Display the running processes</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Deploy-Tec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>egg  + sequelize + mysql + jwt + vue 实现全栈服务（一）</title>
      <link href="/2021/08/31/egg-01/"/>
      <url>/2021/08/31/egg-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Egg-js的常用配置"><a href="#Egg-js的常用配置" class="headerlink" title="Egg.js的常用配置"></a>Egg.js的常用配置</h1><h3 id="一、egg-js常用配置（在config目录下根据不同环境配置-config-default-或config-prod-js）"><a href="#一、egg-js常用配置（在config目录下根据不同环境配置-config-default-或config-prod-js）" class="headerlink" title="一、egg.js常用配置（在config目录下根据不同环境配置 config.default.或config.prod.js）"></a>一、egg.js常用配置（在config目录下根据不同环境配置 <em>config.default.或config.prod.js</em>）</h3><h4 id="1-数据库链接配置"><a href="#1-数据库链接配置" class="headerlink" title="1:数据库链接配置"></a>1:数据库链接配置</h4><pre><code>// mysql config  config.dbConfig = &#123;    database: process.env.DB_DATABASE || &#39;user&#39;,    host: process.env.DB_HOST || &#39;124.70.215.***&#39;,    port: process.env.DB_PORT || &#39;3306&#39;,    username: process.env.DB_USER || &#39;root&#39;,    password: process.env.DB_PASSWORD || &#39;******&#39;,    charset: &#39;utf8mb4&#39;,    collate: &#39;utf8_general_ci&#39;  &#125;</code></pre><h4 id="2-jwt配置"><a href="#2-jwt配置" class="headerlink" title="2:jwt配置"></a>2:jwt配置</h4><pre><code>// jwt 配置  config.jwt = &#123;    secret: &#39;zzestlgcjwtsecret&#39;,    getToken(ctx) &#123;      if (        ctx.headers.authorization &amp;&amp;        (ctx.headers.authorization.split(&#39; &#39;)[0] === &#39;Bearer&#39; ||          ctx.headers.authorization.split(&#39; &#39;)[0] === &#39;Token&#39;)      ) &#123;        return ctx.headers.authorization.split(&#39; &#39;)[1]      &#125; else if (ctx.query &amp;&amp; ctx.query.token) &#123;        return ctx.query.token      &#125;      return null    &#125;  &#125;</code></pre><h4 id="3-跨域配置"><a href="#3-跨域配置" class="headerlink" title="3:跨域配置"></a>3:跨域配置</h4><pre><code>// 跨域配置  config.cors = &#123;    origin: &#39;*&#39;,    allowMethods: &#39;GET, HEAD, PUT, POST, DELETE, PATCH, OPTIONS&#39;  &#125;</code></pre><h4 id="4-部署指定端口配置"><a href="#4-部署指定端口配置" class="headerlink" title="4:部署指定端口配置"></a>4:部署指定端口配置</h4><pre><code>// 指定端口启动config.cluster = &#123;    listen: &#123;      path: &#39;&#39;,      port: 3005,      hostname: &#39;0.0.0.0&#39;,    &#125;  &#125;;</code></pre><h4 id="5-常用插件的配置"><a href="#5-常用插件的配置" class="headerlink" title="5:常用插件的配置"></a>5:常用插件的配置</h4><pre><code>    // Sequelize插件  sequelize: &#123;    enable: true,    package: &#39;egg-sequelize&#39;  &#125;,  // 校验插件  validate: &#123;    enable: true,    package: &#39;egg-validate&#39;  &#125;,  // jwt插件  jwt: &#123;    enable: true,    package: &#39;egg-jwt&#39;  &#125;,  // 子路由  routerPlus: &#123;    enable: true,    package: &#39;egg-router-plus&#39;  &#125;,  // 跨域  cors: &#123;    enable: true,    package: &#39;egg-cors&#39;  &#125;,</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egg-scripts start --daemon 启动于 egg-bin dev 的区别在于前者是在后台运行</span><br></pre></td></tr></table></figure><h5 id="注意项目在dev环境启动的时候要注意package-json中所对应的指令。"><a href="#注意项目在dev环境启动的时候要注意package-json中所对应的指令。" class="headerlink" title="注意项目在dev环境启动的时候要注意package.json中所对应的指令。"></a>注意项目在dev环境启动的时候要注意package.json中所对应的指令。</h5><h5 id="由于框架的配置功能比较强大，有不同环境变量，又有框架、插件、应用等很多地方配置，如果配置不生效时可以查看下-root-run-application-config-json（worker-进程配置）-和-root-run-agent-config-json（agent-进程配置）-这两个文件。"><a href="#由于框架的配置功能比较强大，有不同环境变量，又有框架、插件、应用等很多地方配置，如果配置不生效时可以查看下-root-run-application-config-json（worker-进程配置）-和-root-run-agent-config-json（agent-进程配置）-这两个文件。" class="headerlink" title="由于框架的配置功能比较强大，有不同环境变量，又有框架、插件、应用等很多地方配置，如果配置不生效时可以查看下 ${root}/run/application_config.json（worker 进程配置） 和 ${root}/run/agent_config.json（agent 进程配置） 这两个文件。"></a>由于框架的配置功能比较强大，有不同环境变量，又有框架、插件、应用等很多地方配置，如果配置不生效时可以查看下 ${root}/run/application_config.json（worker 进程配置） 和 ${root}/run/agent_config.json（agent 进程配置） 这两个文件。</h5>]]></content>
      
      
      <categories>
          
          <category> BackEnd-Tec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
            <tag> vue </tag>
            
            <tag> sequelize </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要有node.js中间层？</title>
      <link href="/2021/08/31/hello-world/"/>
      <url>/2021/08/31/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要有node-js中间层？"><a href="#为什么要有node-js中间层？" class="headerlink" title="为什么要有node.js中间层？"></a>为什么要有node.js中间层？</h3><p>目前流行前后端分离开发方式。虽然这里分离干净了，分工也很明确了，看似一切都那么美好，but…我们也很容易发现问题的所在：<br>1:Client-side Model 是 Server-side Model 的加工<br>2:Client-side View 跟 Server-side是 不同层次的东西<br>3:Client-side的Controller 跟 Sever-side的Controller 各搞各的<br>4:Client-side的Route 但是 Server-side 可能没有</p><p>服务端和客户端各层职责重叠，大家各搞各的，很难统一具体要做的事情。并且可能会伴随着一些性能上的问题。最具体的表现就是我们常用的 SPA 应用：</p><p>1:渲染，取值都在客户端进行，有性能的问题<br>2:需要等待资源到齐才能进行，会有短暂白屏与闪动<br>3:在移动设备低速网路的体验奇差无比<br>4:渲染都在客户端，模版无法重用，SEO 实现 麻烦</p><p>这个就是中间层nodejs的意义，下面我们来看一下常见的业务场景：</p><h4 id="1-接口数据可靠性修复"><a href="#1-接口数据可靠性修复" class="headerlink" title="1. 接口数据可靠性修复"></a>1. 接口数据可靠性修复</h4><p>有的时候服务端返回给我们的数据可能并不是前端想要的结构，所有用到的展现数据都是后端通过异步接口(AJAX/JSONP)的方式提供的，前端只管展现。但是后端经常提供后端的数据逻辑，在前端还需要去处理这些数据逻辑。</p><h4 id="2-页面性能优化-和-SEO"><a href="#2-页面性能优化-和-SEO" class="headerlink" title="2. 页面性能优化 和 SEO"></a>2. 页面性能优化 和 SEO</h4><p>有的时候我们做单页面应用，经常会碰到首屏加载性能问题，这个时候如果我们接了中间层nodejs的话，那么我们可以把首屏渲染的任务交给nodejs去做，次屏的渲染依然走之前的浏览器渲染。（前端换页，浏览器端渲染，直接输入网址，服务器渲染）服务端渲染对页面进行拼接直出html字符串，可以大幅提高首屏渲染的时间，减少用户的等待时间。这种形式应用最广的比如 Vue 的服务端渲染，里面也有相关的介绍。其次对于单页面的SEO优化也是很好地处理方式，由于目前的ajax并不被搜索百度等搜索引擎支持，所以如果想要得到爬虫的支持，那么服务端渲染也是一种解决方法。</p><h4 id="3-淘宝常见的需求解决方案"><a href="#3-淘宝常见的需求解决方案" class="headerlink" title="3. 淘宝常见的需求解决方案"></a>3. 淘宝常见的需求解决方案</h4><p>需求：在淘宝，单日四亿PV，页面数据来自各个不同接口，为了不影响体验，先产生页面框架后，在发起多个异步请求取数据更新页面，这些多出来的请求带来的影响不小，尤其在无线端。解决方案：在 NodeJS 端使用 Bigpiper 技术，合并请求，降低负担，分批输出，不影响体验。同时可以拆分大接口为独立小接口，并发请求。串行 =&gt; 并行，大幅缩短请求时间。</p>]]></content>
      
      
      <categories>
          
          <category> BackEnd-Tec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS引用类型的用法</title>
      <link href="/2021/08/31/object-type/"/>
      <url>/2021/08/31/object-type/</url>
      
        <content type="html"><![CDATA[<h4 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h4><pre><code>  const originData = [&quot;1#12&quot;, &quot;2#12&quot;, &quot;3#13&quot;, &quot;5#13&quot;, &quot;4#13&quot;, &quot;1#14&quot;];  </code></pre><p><code>#</code>后面为projectId ，前面为modelId</p><h4 id="目标数据"><a href="#目标数据" class="headerlink" title="目标数据"></a>目标数据</h4><pre><code>const targetData = [  &#123; projectId: &quot;12&quot;, modelId: [&quot;1&quot;, &quot;2&quot;] &#125;,  &#123; projectId: &quot;13&quot;, modelId: [&quot;3&quot;, &quot;5&quot;, &quot;4&quot;] &#125;,  &#123; projectId: &quot;14&quot;, modelId: [&quot;1&quot;] &#125;,];</code></pre><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><pre><code> function getList(list) &#123;  const temp = &#123;&#125;; // 定义的临时数据  const arr = [];  list.forEach((val) =&gt; &#123;    // 分割需要用到的数据    const [mid, pid] = val.split(&quot;#&quot;);    // 如果临时数据中存在当前项的projectId，则在temp[pid]值中追加modelId    if (temp[pid]) &#123;      temp[pid].push(mid);    &#125; else &#123;    // 如果不存在临时数据中存储当前projectId对应modelId的值      temp[pid] = [mid];      arr.push(&#123;        projectId: pid,        modelId: temp[pid], // 这里取temp中projectId所对应的值「其实就是引用类型的用法」      &#125;);    &#125;  &#125;);  return arr;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd-Tec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
