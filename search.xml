<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>my-resume</title>
      <link href="/2021/08/27/my-resume/"/>
      <url>/2021/08/27/my-resume/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>世界的阴暗面，和我们假装美好的教育</title>
      <link href="/2021/08/27/book-record/"/>
      <url>/2021/08/27/book-record/</url>
      
        <content type="html"><![CDATA[<h1 id="世界的阴暗面，和我们假装美好的教育"><a href="#世界的阴暗面，和我们假装美好的教育" class="headerlink" title="世界的阴暗面，和我们假装美好的教育"></a>世界的阴暗面，和我们假装美好的教育</h1><p>—-读《房思琪的初恋乐园》有感</p><p>作者：柒祭·落</p><p><code>读完整本小说，整个人都沉浸在那种悲伤中，想到之前看过的《素媛》和《熔炉》，小说中最让我心痛的一个词叫“世界的背面”。如果思琪活在世界的正面，健康快乐的长大，像大多数同龄孩子一样，为考试成绩而忧愁，为同桌的男孩而害羞，就是我们大多数人的人生。可我们都忘了，这个世界还有背面，那些我们无法言说无法体会的痛楚和丑陋，依然在如今这个看似美好的世界，活生生的存在着。</code></p><p>读了小说，看了林奕含的采访视频，发现那个看着温柔美好的女孩子，对文学有着很深的爱，读过的书，书里的人，写书的人，都成为了她的信仰，成为了她深深的爱，而这也成了她对老师又爱又恨的原因。她爱老师和她信仰相同，在她对文学有懵懵懂懂的理解时，老师是那个让她无比崇拜的人，可是在她还没有真正理解文学里的爱时，她崇拜的人却深深的伤害了她。也许最后，林奕含的自杀，不是因为那段痛苦的回忆，而是她无法接受她爱的信仰也有可能只是一种假象。</p><p>那些书写了美好世界，完美爱情的人，在现实世界，却可能是个虐打妻子的暴力男。林奕含无法接受这样的虚假。</p><blockquote><p>最后，让我深思而心痛的是，我们缺失的性教育。</p></blockquote><p>在思琪问妈妈，我们家什么都有，就是没有性教育的时候，妈妈的回答是只有需要性的人才需要性教育，所谓教育不就是这样吗？</p><p>所谓教育不就是这样吗？</p><p>我们需要什么，或者说我们认为孩子需要什么，我们就教给他们什么。可是孩子会在生活中遇到我们以为不会发生的事，而这种时候，孩子会很迷茫，TA不知道什么是对什么是错，也不知道该如何面对。而试探性的问问父母，父母的反应也依旧停留于已有的认知，而没有思考孩子为什么会这么问。思琪的父母如此，怡婷的父母同样，所以怡婷才会在思琪痛苦的时候，没有帮助和陪伴她，反而给了她更多的伤害。因为怡婷也不知道思琪是受到了伤害，她认为这件事超出了教育认知里的常规，所以就是错的。</p><p>纵然有人想努力用各种方式，将这个世界的阴暗面撕开，纵然有很多人在看过后愤怒，心痛，可我们却不得不承认，在愤怒和心痛过之后，我们依然无法阻止这样的事继续发生。我们读书，在书里看到美好的世界，也看到阴暗的世界。这一切，都是真实的，真实的美好，也真实的阴暗，并且，我们无力改变。</p><h3 id="这就是让人最心痛的。"><a href="#这就是让人最心痛的。" class="headerlink" title="这就是让人最心痛的。"></a>这就是让人最心痛的。</h3><p>1991年出生，2017年离世，心痛那个美好姑娘的美好年华，就这样结束。被这个世界的阴暗面，和我们假装美好的教育，合伙谋杀。也许原本，她不用这样过一生。</p>]]></content>
      
      
      <categories>
          
          <category> Reading-Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>egg  + sequelize + mysql + jwt + vue 实现全栈服务（一）</title>
      <link href="/2021/08/27/egg-01/"/>
      <url>/2021/08/27/egg-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Egg-js的常用配置"><a href="#Egg-js的常用配置" class="headerlink" title="Egg.js的常用配置"></a>Egg.js的常用配置</h1><h3 id="一、egg-js常用配置（在config目录下根据不同环境配置-config-default-或config-prod-js）"><a href="#一、egg-js常用配置（在config目录下根据不同环境配置-config-default-或config-prod-js）" class="headerlink" title="一、egg.js常用配置（在config目录下根据不同环境配置 config.default.或config.prod.js）"></a>一、egg.js常用配置（在config目录下根据不同环境配置 <em>config.default.或config.prod.js</em>）</h3><h4 id="1-数据库链接配置"><a href="#1-数据库链接配置" class="headerlink" title="1:数据库链接配置"></a>1:数据库链接配置</h4><pre><code>// mysql config  config.dbConfig = &#123;    database: process.env.DB_DATABASE || &#39;user&#39;,    host: process.env.DB_HOST || &#39;124.70.215.***&#39;,    port: process.env.DB_PORT || &#39;3306&#39;,    username: process.env.DB_USER || &#39;root&#39;,    password: process.env.DB_PASSWORD || &#39;******&#39;,    charset: &#39;utf8mb4&#39;,    collate: &#39;utf8_general_ci&#39;  &#125;</code></pre><h4 id="2-jwt配置"><a href="#2-jwt配置" class="headerlink" title="2:jwt配置"></a>2:jwt配置</h4><pre><code>// jwt 配置  config.jwt = &#123;    secret: &#39;zzestlgcjwtsecret&#39;,    getToken(ctx) &#123;      if (        ctx.headers.authorization &amp;&amp;        (ctx.headers.authorization.split(&#39; &#39;)[0] === &#39;Bearer&#39; ||          ctx.headers.authorization.split(&#39; &#39;)[0] === &#39;Token&#39;)      ) &#123;        return ctx.headers.authorization.split(&#39; &#39;)[1]      &#125; else if (ctx.query &amp;&amp; ctx.query.token) &#123;        return ctx.query.token      &#125;      return null    &#125;  &#125;</code></pre><h4 id="3-跨域配置"><a href="#3-跨域配置" class="headerlink" title="3:跨域配置"></a>3:跨域配置</h4><pre><code>// 跨域配置  config.cors = &#123;    origin: &#39;*&#39;,    allowMethods: &#39;GET, HEAD, PUT, POST, DELETE, PATCH, OPTIONS&#39;  &#125;</code></pre><h4 id="4-部署指定端口配置"><a href="#4-部署指定端口配置" class="headerlink" title="4:部署指定端口配置"></a>4:部署指定端口配置</h4><pre><code>// 指定端口启动config.cluster = &#123;    listen: &#123;      path: &#39;&#39;,      port: 3005,      hostname: &#39;0.0.0.0&#39;,    &#125;  &#125;;</code></pre><h4 id="5-常用插件的配置"><a href="#5-常用插件的配置" class="headerlink" title="5:常用插件的配置"></a>5:常用插件的配置</h4><pre><code>    // Sequelize插件  sequelize: &#123;    enable: true,    package: &#39;egg-sequelize&#39;  &#125;,  // 校验插件  validate: &#123;    enable: true,    package: &#39;egg-validate&#39;  &#125;,  // jwt插件  jwt: &#123;    enable: true,    package: &#39;egg-jwt&#39;  &#125;,  // 子路由  routerPlus: &#123;    enable: true,    package: &#39;egg-router-plus&#39;  &#125;,  // 跨域  cors: &#123;    enable: true,    package: &#39;egg-cors&#39;  &#125;,</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egg-scripts start --daemon 启动于 egg-bin dev 的区别在于前者是在后台运行</span><br></pre></td></tr></table></figure><h5 id="注意项目在dev环境启动的时候要注意package-json中所对应的指令。"><a href="#注意项目在dev环境启动的时候要注意package-json中所对应的指令。" class="headerlink" title="注意项目在dev环境启动的时候要注意package.json中所对应的指令。"></a>注意项目在dev环境启动的时候要注意package.json中所对应的指令。</h5><h5 id="由于框架的配置功能比较强大，有不同环境变量，又有框架、插件、应用等很多地方配置，如果配置不生效时可以查看下-root-run-application-config-json（worker-进程配置）-和-root-run-agent-config-json（agent-进程配置）-这两个文件。"><a href="#由于框架的配置功能比较强大，有不同环境变量，又有框架、插件、应用等很多地方配置，如果配置不生效时可以查看下-root-run-application-config-json（worker-进程配置）-和-root-run-agent-config-json（agent-进程配置）-这两个文件。" class="headerlink" title="由于框架的配置功能比较强大，有不同环境变量，又有框架、插件、应用等很多地方配置，如果配置不生效时可以查看下 ${root}/run/application_config.json（worker 进程配置） 和 ${root}/run/agent_config.json（agent 进程配置） 这两个文件。"></a>由于框架的配置功能比较强大，有不同环境变量，又有框架、插件、应用等很多地方配置，如果配置不生效时可以查看下 ${root}/run/application_config.json（worker 进程配置） 和 ${root}/run/agent_config.json（agent 进程配置） 这两个文件。</h5>]]></content>
      
      
      <categories>
          
          <category> BackEnd-Tec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
            <tag> sequelize </tag>
            
            <tag> jwt </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要有node.js中间层？</title>
      <link href="/2021/08/27/hello-world/"/>
      <url>/2021/08/27/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要有node-js中间层？"><a href="#为什么要有node-js中间层？" class="headerlink" title="为什么要有node.js中间层？"></a>为什么要有node.js中间层？</h3><p>目前流行前后端分离开发方式。虽然这里分离干净了，分工也很明确了，看似一切都那么美好，but…我们也很容易发现问题的所在：<br>1:Client-side Model 是 Server-side Model 的加工<br>2:Client-side View 跟 Server-side是 不同层次的东西<br>3:Client-side的Controller 跟 Sever-side的Controller 各搞各的<br>4:Client-side的Route 但是 Server-side 可能没有</p><p>服务端和客户端各层职责重叠，大家各搞各的，很难统一具体要做的事情。并且可能会伴随着一些性能上的问题。最具体的表现就是我们常用的 SPA 应用：</p><p>1:渲染，取值都在客户端进行，有性能的问题<br>2:需要等待资源到齐才能进行，会有短暂白屏与闪动<br>3:在移动设备低速网路的体验奇差无比<br>4:渲染都在客户端，模版无法重用，SEO 实现 麻烦</p><p>这个就是中间层nodejs的意义，下面我们来看一下常见的业务场景：</p><h4 id="1-接口数据可靠性修复"><a href="#1-接口数据可靠性修复" class="headerlink" title="1. 接口数据可靠性修复"></a>1. 接口数据可靠性修复</h4><p>有的时候服务端返回给我们的数据可能并不是前端想要的结构，所有用到的展现数据都是后端通过异步接口(AJAX/JSONP)的方式提供的，前端只管展现。但是后端经常提供后端的数据逻辑，在前端还需要去处理这些数据逻辑。</p><h4 id="2-页面性能优化-和-SEO"><a href="#2-页面性能优化-和-SEO" class="headerlink" title="2. 页面性能优化 和 SEO"></a>2. 页面性能优化 和 SEO</h4><p>有的时候我们做单页面应用，经常会碰到首屏加载性能问题，这个时候如果我们接了中间层nodejs的话，那么我们可以把首屏渲染的任务交给nodejs去做，次屏的渲染依然走之前的浏览器渲染。（前端换页，浏览器端渲染，直接输入网址，服务器渲染）服务端渲染对页面进行拼接直出html字符串，可以大幅提高首屏渲染的时间，减少用户的等待时间。这种形式应用最广的比如 Vue 的服务端渲染，里面也有相关的介绍。其次对于单页面的SEO优化也是很好地处理方式，由于目前的ajax并不被搜索百度等搜索引擎支持，所以如果想要得到爬虫的支持，那么服务端渲染也是一种解决方法。</p><h4 id="3-淘宝常见的需求解决方案"><a href="#3-淘宝常见的需求解决方案" class="headerlink" title="3. 淘宝常见的需求解决方案"></a>3. 淘宝常见的需求解决方案</h4><p>需求：在淘宝，单日四亿PV，页面数据来自各个不同接口，为了不影响体验，先产生页面框架后，在发起多个异步请求取数据更新页面，这些多出来的请求带来的影响不小，尤其在无线端。解决方案：在 NodeJS 端使用 Bigpiper 技术，合并请求，降低负担，分批输出，不影响体验。同时可以拆分大接口为独立小接口，并发请求。串行 =&gt; 并行，大幅缩短请求时间。</p>]]></content>
      
      
      <categories>
          
          <category> BackEnd-Tec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS引用类型的用法</title>
      <link href="/2021/08/27/object-type/"/>
      <url>/2021/08/27/object-type/</url>
      
        <content type="html"><![CDATA[<h4 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h4><pre><code>  const originData = [&quot;1#12&quot;, &quot;2#12&quot;, &quot;3#13&quot;, &quot;5#13&quot;, &quot;4#13&quot;, &quot;1#14&quot;];  </code></pre><p><code>#</code>后面为projectId ，前面为modelId</p><h4 id="目标数据"><a href="#目标数据" class="headerlink" title="目标数据"></a>目标数据</h4><pre><code>const targetData = [  &#123; projectId: &quot;12&quot;, modelId: [&quot;1&quot;, &quot;2&quot;] &#125;,  &#123; projectId: &quot;13&quot;, modelId: [&quot;3&quot;, &quot;5&quot;, &quot;4&quot;] &#125;,  &#123; projectId: &quot;14&quot;, modelId: [&quot;1&quot;] &#125;,];</code></pre><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><pre><code> function getList(list) &#123;  const temp = &#123;&#125;; // 定义的临时数据  const arr = [];  list.forEach((val) =&gt; &#123;    // 分割需要用到的数据    const [mid, pid] = val.split(&quot;#&quot;);    // 如果临时数据中存在当前项的projectId，则在temp[pid]值中追加modelId    if (temp[pid]) &#123;      temp[pid].push(mid);    &#125; else &#123;    // 如果不存在临时数据中存储当前projectId对应modelId的值      temp[pid] = [mid];      arr.push(&#123;        projectId: pid,        modelId: temp[pid], // 这里取temp中projectId所对应的值「其实就是引用类型的用法」      &#125;);    &#125;  &#125;);  return arr;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd-Tec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
